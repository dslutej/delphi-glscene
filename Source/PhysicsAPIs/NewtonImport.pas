{                                                                            
 Newton Game Dynamics Header Translation (Delphi/FreePascal)                  
  Newton Version 3.14 
  Generated by NewtonDoc on 31/03/2017 16:17:44  


********************************************************************************
*                                                                              *
* Copyright (c) <2003-2016> <Julio Jerez, Newton Game Dynamics>                *
*                                                                              *
* This software is provided 'as-is', without any express or implied            *
* warranty. In no event will the authors be held liable for any damages        *
* arising from the use of this software.                                       *
*                                                                              *
* Permission is granted to anyone to use this software for any purpose,        *
* including commercial applications, and to alter it and redistribute it       *
* freely, subject to the following restrictions:                               *
*                                                                              *
* 1. The origin of this software must not be misrepresented; you must not      *
* claim that you wrote the original software. If you use this software         *
* in a product, an acknowledgment in the product documentation would be        *
* appreciated but is not required.                                             *
*                                                                              *
* 2. Altered source versions must be plainly marked as such, and must not be   *
* misrepresented as being the original software.                               *
*                                                                              *
* 3. This notice may not be removed or altered from any source distribution.   *
*                                                                              *
********************************************************************************
}

unit NewtonImport;

{== Local Defines ==
  __NONDELPHI__            - Enables compatiblity with compilers other than Delphi.
                             Note that pascaldefines.inc and newtonpascal.inc
                             are protected under the Mozilla Public License.

 == Conditionals ==
 Declare the Following in Projects->Options->Conditional defines to enable them:
  __USE_DOUBLE_PRECISION__ - Toggles Double Precision. DLL used must match this setting.

 == Local Defines ==}
 //{$DEFINE __NONDELPHI__}



{$IFDEF __NONDELPHI__}
 {$I pascaldefines.inc}
{$ENDIF}

interface

const
{$IFDEF WIN32}
   NEWTON_API = 'Newton.dll';
{$ENDIF}
{$IFDEF WIN64}
   NEWTON_API = 'Newton64.dll';
{$ENDIF}

 NEWTON_MAJOR_VERSION = 3;
 NEWTON_MINOR_VERSION = 14;
 NEWTON_BROADPHASE_DEFAULT = 0;
 NEWTON_BROADPHASE_PERSINTENT = 1;
 NEWTON_DYNAMIC_BODY = 0;
 NEWTON_KINEMATIC_BODY = 1;
 SERIALIZE_ID_SPHERE = 0;
 SERIALIZE_ID_CAPSULE = 1;
 SERIALIZE_ID_CYLINDER = 2;
 SERIALIZE_ID_CHAMFERCYLINDER = 3;
 SERIALIZE_ID_BOX = 4;
 SERIALIZE_ID_CONE = 5;
 SERIALIZE_ID_CONVEXHULL = 6;
 SERIALIZE_ID_NULL = 7;
 SERIALIZE_ID_COMPOUND = 8;
 SERIALIZE_ID_TREE = 9;
 SERIALIZE_ID_HEIGHTFIELD = 10;
 SERIALIZE_ID_CLOTH_PATCH = 11;
 SERIALIZE_ID_DEFORMABLE_SOLID = 12;
 SERIALIZE_ID_USERMESH = 13;
 SERIALIZE_ID_SCENE = 14;
 SERIALIZE_ID_FRACTURED_COMPOUND = 15;

type
// *****************************************************************************************************************************
//
//  Data Types
//
// *****************************************************************************************************************************

{Pascal to C++}
{$IFDEF __USE_DOUBLE_PRECISION__}
   dFloat = Double;
  {$ELSE}
   dFloat = Single;
  {$ENDIF}
  dFloat64 = Double;
  __int8 = ShortInt;
  __int16 = SmallInt;
  __int32 = LongInt;
  __int64 = Int64;
  NChar = ShortInt;
  Unsigned_char = Byte;
  Short = SmallInt;
  Unsigned_short = Word;
  Long = LongInt;
  dLong = ^Int64;
  Unsigned_long = LongWord;
  Unsigned_int = Cardinal;
  size_t = Cardinal;
  CharArray = Array [0..255] of Char;
  PdFloat                      = ^dFloat;
  PdFloat64  = ^dFloat64;
  PdLong = ^dLong;
  PInt = ^Integer;
  P__int8 = ^__int8;
  P__int16 = ^__int16;
  P__int32 = ^__int32;
  P__int64 = ^__int64;
  P2Char = ^NChar;
  PUnsigned_char = ^Unsigned_char;
  PShort = ^Short;
  PUnsigned_short = ^Unsigned_short;
  PLong = ^Long;
  PUnsigned_long = ^Unsigned_long;
  PUnsigned_int = ^Unsigned_int;
  Psize_t = ^size_t;
  PFloat = ^dFloat;
  PLong_double = ^Extended;
  PCharArray = ^CharArray;

{end Pascal to C++}

{$IFDEF NICE_CODE_PARAMS}
  PNewtonMesh = ^Pointer;
  PNewtonBody = ^Pointer;
  PNewtonWorld = ^Pointer;
  PNewtonJoint = ^Pointer;
  PNewtonContact = ^Pointer;
  PNewtonMaterial = ^Pointer;
  PNewtonCollision = ^Pointer;
  //PNewtonSceneProxy = ^Pointer;
  PNewtonBreakableComponentMesh = ^Pointer;
  PNewtonMeshVertex = ^Pointer;
  PNewtonMeshEdge = ^Pointer;
  PNewtonMeshFace = ^Pointer;
  PNewtonMeshPoint= ^Pointer;
  // JointLibrary
  PNewtonUserJoint = ^Pointer;

  //PNewtonRagDoll = ^Pointer;
  //PNewtonRagDollBone = ^Pointer;
{$ELSE}

  PNewtonMesh = Pointer;
  PNewtonBody = Pointer;
  PNewtonWorld = Pointer;
  PNewtonJoint = Pointer;
  PNewtonContact = Pointer;
  PNewtonMaterial = Pointer;
  PNewtonCollision = Pointer;
  PNewtonSceneProxy = Pointer;
  PNewtonBreakableComponentMesh = Pointer;
  PNewtonMeshVertex = Pointer;
  PNewtonMeshEdge = Pointer;
  PNewtonMeshFace = Pointer;
  PNewtonMeshPoint= Pointer;
  // JointLibrary
  PNewtonUserJoint = Pointer;

  //PNewtonRagDoll = Pointer;
  //PNewtonRagDollBone = Pointer;
{$ENDIF}

        // NewtonCollisionInfoRecord

 TNewtonBoxParam = Packed Record
  m_x,
  m_y,
  m_z                    : dFloat;
 end;

       TNewtonSphereParam = packed record
             m_r0,
             m_r1,
             m_r2: dfloat;
      end;

      TNewtonCylinderParam = packed record
          m_r0,
          m_r1,
        m_height: dfloat;
      end;

      TNewtonCapsuleParam = packed record
          m_r0,
          m_r1,
        m_height: dfloat;
      end;

      TNewtonConeParam = packed record
          m_r,
          m_height: dfloat;
      end;

 TNewtonTaperedCapsuleParam = Packed Record
  m_radio0,
  m_radio1,
  m_height               : dFloat;
 end;


 TNewtonTaperedCylinderParam = Packed Record
  m_radio0,
  m_radio1,
  m_height               : dFloat;
 end;

 TNewtonChamferCylinderParam = Packed Record
  m_radio,
  m_height               : dFloat;
 end;

 TNewtonConvexHullParam = Packed Record
  m_vertexCount,
  m_vertexStrideInBytes,
  m_faceCount            : Integer;
  m_vertex               : PdFloat;
 end;

      TNewtonConvexHullModifierParam = packed record
         m_chidren: PNewtonCollision;
      end;

 TNewtonCompoundCollisionParam = Packed Record
  m_chidrenCount         : Integer;
 end;


 TNewtonCollisionTreeParam = Packed Record
  m_vertexCount,
  m_indexCount           : Integer;
 end;

 TNewtonDeformableMeshParam = Packed Record
  m_vertexCount,
  m_triangleCount,
  m_vertexStrideInBytes  : Integer;
  m_indexList            : PWord;
  m_vertexList           : PdFloat;
 end;


 TNewtonHeightFieldCollisionParam = Packed Record
  m_width,
  m_height,
  m_gridsDiagonals,
  m_elevationDataType     : Integer;// 0 = 32 bit floats, 1 = unsigned 16 bit integers
  m_verticalScale         : dFloat;
  m_horizonalScale_x : dFloat;
  m_horizonalScale_z : dFloat;
  m_horizonalDisplacementScale_x : dFloat;
  m_horizonalDisplacementScale_z : dFloat;
  m_vertialElevation      : Pointer;
  m_horizotalDisplacement : PSmallInt;
  m_atributes             : PShortInt;
 end;

      TNewtonSceneCollisionParam = packed record
          m_childrenProxyCount: integer;
      end;

      TNewtonCollisionNullParam = packed record
       // nothing.
      end;

      TNewtonCollisionInfoRecord = packed record
    m_offsetMatrix: array[0..3,0..3] of dfloat;
      m_collisionType,                 // tag id to identify the collision primitive
      m_referenceCount: integer;       // the current reference count for this collision
    m_collisionUserID: integer;
  case Integer of
       SERIALIZE_ID_SPHERE           : (sdSphere             : TNewtonSphereParam);
       SERIALIZE_ID_CAPSULE          : (sdCapsule            : TNewtonCapsuleParam);
	   SERIALIZE_ID_CYLINDER         : (sdCylinder           : TNewtonCylinderParam);
       SERIALIZE_ID_CHAMFERCYLINDER  : (sdChamferCylinder    : TNewtonChamferCylinderParam);
       SERIALIZE_ID_BOX              : (sdBox                : TNewtonBoxParam);
       SERIALIZE_ID_CONE             : (sdCone               : TNewtonConeParam);
       SERIALIZE_ID_CONVEXHULL       : (sdConvexHull         : TNewtonConvexHullParam);
       SERIALIZE_ID_NULL             : (sdNull               : TNewtonCollisionNullParam);
       SERIALIZE_ID_COMPOUND         : (sdCompound           : TNewtonCompoundCollisionParam);
       SERIALIZE_ID_TREE             : (sdTree               : TNewtonCollisionTreeParam);
       SERIALIZE_ID_HEIGHTFIELD      : (sdHeightField        : TNewtonHeightFieldCollisionParam);
       SERIALIZE_ID_DEFORMABLE_SOLID : (sdDeformableMesh     : TNewtonDeformableMeshParam);
       SERIALIZE_ID_USERMESH         : (sdUserMesh           : Array[0..63] of dFloat);
       SERIALIZE_ID_SCENE            : (sdSceneCollision     : TNewtonSceneCollisionParam);
  end;

  PNewtonCollisionInfoRecord = ^TNewtonCollisionInfoRecord;

  PNewtonJointRecord = ^NewtonJointRecord;
  NewtonJointRecord = record
    m_attachmenMatrix_0 : array[ 0..3,0..3 ] of dfloat;
    m_attachmenMatrix_1 : array[ 0..3,0..3 ] of dfloat;
    m_minLinearDof      : array[ 0..2 ] of dfloat;
    m_maxLinearDof      : array[ 0..2 ] of dfloat;
    m_minAngularDof     : array[ 0..2 ] of dfloat;
    m_maxAngularDof     : array[ 0..2 ] of dfloat;
    m_attachBody_0      : PNewtonBody;
    m_attachBody_1      : PNewtonBody;
    m_extraParameters   : array[ 0..15 ] of dfloat;
    m_bodiesCollisionOn : integer;
    m_descriptionType   : array[ 0..31 ] of NChar;
  end;


  PNewtonUserMeshCollisionCollideDesc = ^NewtonUserMeshCollisionCollideDesc;
  NewtonUserMeshCollisionCollideDesc = record
    m_boxP0               : array[ 0..3 ] of dfloat; // lower bounding box of intersection query in local space
    m_boxP1               : array[ 0..3 ] of dfloat; // upper bounding box of intersection query in local space
    m_threadNumber        : integer;                    // current thread executing this query
    m_faceCount           : integer;                    // the application should set here how many polygons intersect the query box
    m_vertexStrideInBytes : integer;                    // the application should set here the size of each vertex
    m_userData            : Pointer;                // user data passed to the collision geometry at creation time
    m_vertex              : ^dfloat;                 // the application should the pointer to the vertex array.
    m_userAttribute       : ^integer;                   // the application should set here the pointer to the user data, one for each face
    m_faceIndexCount      : ^integer;                   // the application should set here the pointer to the vertex count of each face.
    m_faceVertexIndex     : ^integer;                   // the application should set here the pointer index array for each vertex on a face.
    m_objBody             : PNewtonBody;            // pointer to the colliding body
    m_polySoupBody        : PNewtonBody;            // pointer to the rigid body owner of this collision tree
  end;

  PNewtonWorldConvexCastReturnInfo = ^NewtonWorldConvexCastReturnInfo;
  NewtonWorldConvexCastReturnInfo = record
    m_point            : array[ 0..3 ] of dfloat; // collision point in global space
    m_normal           : array[ 0..3 ] of dfloat; // surface normal at collision point in global space
    m_normalOnHitPoint : array[ 0..3 ] of dfloat; // surface normal at the surface of the hit body,
					         // is the same as the normal calculated by a ray cast hitting the body at the hit poi
    m_penetration      : dfloat;                  // contact penetration at collision point
    m_contactID        : integer;                    // collision ID at contact point
    m_hitBody          : PNewtonBody;            // body hit at contact point
  end;

  PNewtonUserMeshCollisionRayHitDesc = ^NewtonUserMeshCollisionRayHitDesc;
  NewtonUserMeshCollisionRayHitDesc = record
    m_p0        : array[ 0..3 ] of dfloat; // ray origin in collision local space
    m_p1        : array[ 0..3 ] of dfloat; // ray destination in collision local space
    m_normalOut : array[ 0..3 ] of dfloat; // copy here the normal at the ray intersection
    m_userIdOut : integer;                    // copy here a user defined id for further feedback
    m_userData  : Pointer;                // user data passed to the collision geometry at creation time
  end;


  PNewtonHingeSliderUpdateDesc = ^NewtonHingeSliderUpdateDesc;
  NewtonHingeSliderUpdateDesc = record
    m_accel       : dfloat;
    m_minFriction : dfloat;
    m_maxFriction : dfloat;
    m_timestep    : dfloat;
  end;

 NewtonUserContactPoint = ^TNewtonUserContactPoint;
 TNewtonUserContactPoint = Packed Record
  m_point,
  m_normal               : Array [0..3] of dFloat;
  m_shapeId0             : dLong;
  m_shapeId1             : dLong;
  m_penetration          : dFloat;
  m_unused               : Array [0..2] of Integer;
 end;

 // data structure for interfacing with NewtonMesh
 NewtonMeshDoubleData = ^TNewtonMeshDoubleData;
 TNewtonMeshDoubleData = Packed Record
  m_data          : PdFloat64;
  m_indexList     : PInteger;
  m_strideInBytes : Integer;
 end;
 
 NewtonMeshFloatData = ^TNewtonMeshFloatData;
 TNewtonMeshFloatData = Packed Record
  m_data          : PdFloat;
  m_indexList     : PInteger;
  m_strideInBytes : Integer;
 end;
 
 NewtonMeshVertexFormat = ^TNewtonMeshVertexFormat;
 TNewtonMeshVertexFormat = Packed Record
  m_faceCount : Integer;
  m_faceIndexCount : PInteger;
  m_faceMaterial : PInteger;
  m_vertex : NewtonMeshDoubleData;
  m_normal : NewtonMeshFloatData;
  m_binormal : NewtonMeshFloatData;
  m_uv0 : NewtonMeshFloatData;
  m_uv1 : NewtonMeshFloatData;
  m_vertexColor : NewtonMeshFloatData;
 end;
 // Newton callback functions
PNewtonAllocMemory                        = ^NewtonAllocMemory;
NewtonAllocMemory                         = function( sizeInBytes : integer ) : Pointer; cdecl;

PNewtonFreeMemory                         = ^NewtonFreeMemory;
NewtonFreeMemory                          = procedure( ptr : Pointer; sizeInBytes : integer ); cdecl;

PNewtonDestroyWorld                       = ^NewtonDestroyWorld;
NewtonDestroyWorld                        = procedure( const NewtonWorld : PNewtonWorld ); cdecl;

PNewtonGetTicksCountCallback              = ^NewtonGetTicksCountCallback;
NewtonGetTicksCountCallback               = function () : cardinal; cdecl;

PNewtonSerialize                          = ^NewtonSerialize;
NewtonSerialize                           = procedure( serializeHandle : Pointer; const buffer : Pointer; size : size_t ); cdecl;

PNewtonDeserialize                        = ^NewtonDeserialize;
NewtonDeserialize                         = procedure( serializeHandle : Pointer; buffer : Pointer; size : size_t ); cdecl;

PNewtonUserMeshCollisionDestroyCallback   = ^NewtonUserMeshCollisionDestroyCallback;
NewtonUserMeshCollisionDestroyCallback    = procedure( descData : Pointer ); cdecl;

PNewtonUserMeshCollisionCollideCallback   = ^NewtonUserMeshCollisionCollideCallback;
NewtonUserMeshCollisionCollideCallback    = procedure( NewtonUserMeshCollisionCollideDesc : PNewtonUserMeshCollisionCollideDesc ); cdecl;

PNewtonUserMeshCollisionRayHitCallback    = ^NewtonUserMeshCollisionRayHitCallback;
NewtonUserMeshCollisionRayHitCallback     = function( NewtonUserMeshCollisionRayHitDesc : PNewtonUserMeshCollisionRayHitDesc ) : integer; cdecl;

PNewtonUserMeshCollisionGetCollisionInfo  = ^NewtonUserMeshCollisionGetCollisionInfo;
NewtonUserMeshCollisionGetCollisionInfo   = procedure( userData : Pointer; infoRecord : PNewtonCollisionInfoRecord ); cdecl;

PNewtonUserMeshCollisionGetFacesInAABB    = ^NewtonUserMeshCollisionGetFacesInAABB;
NewtonUserMeshCollisionGetFacesInAABB     = function( userData : Pointer; const p0  : PFloat; const p1 : PFloat; const vertexArray : PFloat; vertexCount : pint;
                                                      vertexStrideInBytes : pint; const indexList : pint; maxIndexCount : integer; const userDataList : pint ) : integer; cdecl;

PNewtonCollisionTreeRayCastCallback       = ^NewtonCollisionTreeRayCastCallback;
NewtonCollisionTreeRayCastCallback        = function(const Body : PNewtonBody; const TreeCollision : PNewtonCollision; interception : dFloat; normal : PFloat; faceId : integer; usedData : Pointer) : dFloat; cdecl;

PNewtonHeightFieldRayCastCallback         = ^NewtonHeightFieldRayCastCallback;
NewtonHeightFieldRayCastCallback          = function(const Body : PNewtonBody; const HeightFieldCollision : PNewtonCollision; Interception : dFloat; Row, Col : Integer; Normal : PFloat; FaceID : Integer; UsedData : Pointer) : dFloat; cdecl;

PNewtonTreeCollisionCallback              = ^NewtonTreeCollisionCallback;
NewtonTreeCollisionCallback               = procedure( const bodyWithTreeCollision : PNewtonBody; const body : PNewtonBody; faceID : integer;
                                                       const vertex : PFloat; vertexstrideInBytes : integer); cdecl;

PNewtonBodyDestructor                     = ^NewtonBodyDestructor;
NewtonBodyDestructor                      = procedure( const body : PNewtonBody ); cdecl;

PNewtonApplyForceAndTorque                = ^NewtonApplyForceAndTorque;
NewtonApplyForceAndTorque                 = procedure( const body : PNewtonBody; timestep : dFloat; threadIndex : integer ); cdecl;

PNewtonSetTransform                       = ^NewtonSetTransform;
NewtonSetTransform                        = procedure( const body : PNewtonBody; const matrix : PFloat; threadIndex : integer ); cdecl;

PNewtonIslandUpdate                       = ^NewtonIslandUpdate;
NewtonIslandUpdate                        = function(const World : PNewtonWorld; islandHandle : Pointer; bodyCount : integer) : integer; cdecl;

PNewtonBodyLeaveWorld                     = ^NewtonBodyLeaveWorld;
NewtonBodyLeaveWorld                      = procedure( const body : PNewtonBody; threadIndex : integer ); cdecl;

PNewtonDestroyBodyByExeciveForce          = ^NewtonDestroyBodyByExeciveForce;
NewtonDestroyBodyByExeciveForce           = procedure( const body : PNewtonBody; const contact : PNewtonJoint ); cdecl;

PNewtonCollisionDestructor                = ^NewtonCollisionDestructor;
NewtonCollisionDestructor                 = procedure (const World : PNewtonWorld; const collision : PNewtonCollision); cdecl;

PNewtonCollisionCompoundBreakableCallback = ^NewtonCollisionCompoundBreakableCallback;
NewtonCollisionCompoundBreakableCallback  = function(const Mesh : PNewtonMesh; userData : Pointer; planeMatrixOut : PFloat) : Integer; cdecl;

PNewtonGetBuoyancyPlane                   = ^NewtonGetBuoyancyPlane;
NewtonGetBuoyancyPlane                    = function(const collisionID : Integer; context : Pointer; const globalSpaceMatrix : PFloat; globalSpacePlane : PFloat ) : Integer; cdecl;

PNewtonWorldRayPrefilterCallback          = ^NewtonWorldRayPrefilterCallback;
NewtonWorldRayPrefilterCallback           = function (const body : PNewtonBody; const collision : PNewtonCollision; userData : Pointer) : cardinal; cdecl;

PNewtonWorldRayFilterCallback             = ^NewtonWorldRayFilterCallback;
NewtonWorldRayFilterCallback              = function( const body : PNewtonBody; const hitNormal: PFloat; collisionID : Integer; userData: Pointer; intersetParam: dFloat ) : dFloat; cdecl;

PNewtonOnAABBOverlap                      = ^NewtonOnAABBOverlap;
NewtonOnAABBOverlap                       = function( const material : PNewtonMaterial; const body0 : PNewtonBody; const body1 : PNewtonBody; threadIndex : Integer ) : integer; cdecl;

PNewtonContactsProcess                    = ^NewtonContactsProcess;
NewtonContactsProcess                     = procedure( const contact : PNewtonJoint; timestep : dFloat; threadIndex : integer ); cdecl;

PNewtonBodyIterator                       = ^NewtonBodyIterator;
NewtonBodyIterator                        = procedure( const body : PNewtonBody; userData : Pointer ); cdecl;

PNewtonJointIterator                      = ^NewtonJointIterator;
NewtonJointIterator                       = procedure( const joint : PNewtonJoint; userData : Pointer ); cdecl;

PNewtonCollisionIterator                  = ^NewtonCollisionIterator;
NewtonCollisionIterator                   = procedure( userData : Pointer; vertexCount : integer; const FaceArray : PFloat; faceId : integer ); cdecl;

PNewtonBallCallBack                       = ^NewtonBallCallBack;
NewtonBallCallBack                        = procedure( const ball : PNewtonJoint; timestep : dFloat ); cdecl;

PNewtonHingeCallBack                      = ^NewtonHingeCallBack;
NewtonHingeCallBack                       = function( const hinge : PNewtonJoint; desc : PNewtonHingeSliderUpdateDesc ) : Unsigned_int; cdecl;

PNewtonSliderCallBack                     = ^NewtonSliderCallBack;
NewtonSliderCallBack                      = function( const slider : PNewtonJoint; desc : PNewtonHingeSliderUpdateDesc ) : Unsigned_int; cdecl;

PNewtonUniversalCallBack                  = ^NewtonUniversalCallBack;
NewtonUniversalCallBack                   = function( const universal : PNewtonJoint; desc : PNewtonHingeSliderUpdateDesc ) : Unsigned_int; cdecl;

PNewtonCorkscrewCallBack                  = ^NewtonCorkscrewCallBack;
NewtonCorkscrewCallBack                   = function( const corkscrew : PNewtonJoint; desc : PNewtonHingeSliderUpdateDesc ) : Unsigned_int; cdecl;

PNewtonUserBilateralCallBack              = ^NewtonUserBilateralCallBack;
NewtonUserBilateralCallBack               = procedure( const userJoint: PNewtonJoint; timestep : dFloat; threadIndex : Integer); cdecl;

PNewtonUserBilateralGetInfoCallBack       = ^NewtonUserBilateralGetInfoCallBack;
NewtonUserBilateralGetInfoCallBack        = procedure( const userJoint : PNewtonJoint; info : PNewtonJointRecord ); cdecl;

PNewtonConstraintDestructor               = ^NewtonConstraintDestructor;
NewtonConstraintDestructor                = procedure( const me : PNewtonJoint ); cdecl;


// *****************************************************************************************************************************
//
// world control functions
//
// *****************************************************************************************************************************
function  NewtonWorldGetVersion( const newtonWorld : PNewtonWorld) : Integer;                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetVersion'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonWorldFloatSize( const newtonWorld : PNewtonWorld) : integer;                                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonWorldFloatSize'{$ELSE}NEWTON_API{$ENDIF __GPC__};


function  NewtonCreate( malloc : NewtonAllocMemory; mfree : NewtonFreeMemory ) : PNewtonWorld;                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonCreate'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonDestroy( const newtonWorld : PNewtonWorld );                                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonDestroy'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonDestroyAllBodies( const newtonWorld : PNewtonWorld );                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonDestroyAllBodies'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonGetMemoryUsed() : Integer;                                                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonGetMemoryUsed'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetMemorySystem( malloc : NewtonAllocMemory; mfree : NewtonFreeMemory );                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonCreate'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonUpdate( const newtonWorld : PNewtonWorld; timestep : dfloat );                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonUpdate'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonInvalidateCache( const newtonWorld : PNewtonWorld);                                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonInvalidateCache'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCollisionUpdate( const newtonWorld : PNewtonWorld);                                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionUpdate'{$ELSE}NEWTON_API{$ENDIF __GPC__};


procedure NewtonSetSolverModel(const NewtonWorld : PNewtonWorld; Model : Integer);                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonSetSolverModel'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSetPlatformArchitecture (const newtonWorld : PNewtonWorld; mode : Integer);                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonSetPlatformArchitecture'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonGetPlatformArchitecture (const newtonWorld : PNewtonWorld; description : PCharArray) : integer;                                       cdecl; external{$IFDEF __GPC__}name 'NewtonGetPlatformArchitecture'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetMultiThreadSolverOnSingleIsland (const newtonWorld : PNewtonWorld; mode : Integer);                                               cdecl; external{$IFDEF __GPC__}name 'NewtonSetMultiThreadSolverOnSingleIsland'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonGetMultiThreadSolverOnSingleIsland (const newtonWorld : PNewtonWorld) : Integer;                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonGetMultiThreadSolverOnSingleIsland'{$ELSE}NEWTON_API{$ENDIF __GPC__};


procedure NewtonSetPerformanceClock (const newtonWorld : PNewtonWorld; NewtonGetTicksCountCallback : PNewtonGetTicksCountCallback);              cdecl; external{$IFDEF __GPC__}name 'NewtonSetPerformanceClock'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonReadPerformanceTicks (const newtonWorld : PNewtonWorld; performanceEntry : cardinal) : cardinal;                                  cdecl; external{$IFDEF __GPC__}name 'NewtonReadPerformanceTicks'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function NewtonReadThreadPerformanceTicks (const NewtonWorld : PNewtonWorld; ThreadIndex: Cardinal) : Cardinal;                                  cdecl; external{$IFDEF __GPC__}name 'NewtonReadThreadPerformanceTicks'{$ELSE}NEWTON_API{$ENDIF __GPC__};


procedure NewtonWorldCriticalSectionLock (const newtonWorld : PNewtonWorld);                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonWorldCriticalSectionLock'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonWorldCriticalSectionUnlock (const newtonWorld : PNewtonWorld);                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonWorldCriticalSectionUnlock'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetThreadsCount (const newtonWorld : PNewtonWorld; threads : Integer);                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonSetThreadsCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonGetThreadsCount (const newtonWorld : PNewtonWorld) : integer;                                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonGetThreadsCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function NewtonGetMaxThreadsCount (const NewtonWorld : PNewtonWorld) : integer;                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonGetMaxThreadsCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetFrictionModel(const NewtonWorld : PNewtonWorld; Model : Integer);                                                                 cdecl; external{$IFDEF __GPC__}name 'NewtonSetFrictionModel'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetMinimumFrameRate( const newtonWorld : PNewtonWorld; frameRate : dfloat );                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonSetMinimumFrameRate'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSetBodyLeaveWorldEvent( const newtonWorld : PNewtonWorld; callback : PNewtonBodyLeaveWorld );                                    cdecl; external{$IFDEF __GPC__}name 'NewtonSetBodyLeaveWorldEvent'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSetWorldSize( const newtonWorld : PNewtonWorld; const minPoint : PFloat; const maxPoint : PFloat );                              cdecl; external{$IFDEF __GPC__}name 'NewtonSetWorldSize'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetIslandUpdateEvent( const newtonWorld : PNewtonWorld; NewtonIslandUpdate : PNewtonIslandUpdate );                              cdecl; external{$IFDEF __GPC__}name 'NewtonSetIslandUpdateEvent'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetCollisionDestructor( const newtonWorld : PNewtonWorld; callback : PNewtonCollisionDestructor );                               cdecl; external{$IFDEF __GPC__}name 'NewtonSetCollisionDestructor'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonSetDestroyBodyByExeciveForce( const newtonWorld : PNewtonWorld; callback : PNewtonDestroyBodyByExeciveForce );                   cdecl; external{$IFDEF __GPC__}name 'NewtonSetDestroyBodyByExeciveForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonWorldForEachJointDo (const newtonWorld : PNewtonWorld; callback : PNewtonJointIterator; userData : Pointer);                     cdecl; external{$IFDEF __GPC__}name 'NewtonWorldForEachJointDo'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonWorldForEachBodyInAABBDo (const newtonWorld : PNewtonWorld; const p0 : PFloat; const p1 : PFloat;
                                          callback : PNewtonBodyIterator; userData : Pointer);                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonWorldForEachBodyInAABBDo'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonWorldSetUserData( const newtonWorld : PNewtonWorld; userData : Pointer);                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonWorldSetUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonWorldGetUserData( const newtonWorld : PNewtonWorld) : Pointer;                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonWorldSetDestructorCallBack( const newtonWorld : PNewtonWorld; NewtonDestroyWorld : PNewtonDestroyWorld);                         cdecl; external{$IFDEF __GPC__}name 'NewtonWorldSetDestructorCallBack'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonWorldGetDestructorCallBack( const newtonWorld : PNewtonWorld) : PNewtonDestroyWorld;                                             cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetDestructorCallBack'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonWorldRayCast( const newtonWorld : PNewtonWorld; const p0 : PFloat; const p1 : PFloat;
                              filter : PNewtonWorldRayFilterCallback; userData: Pointer;
                              prefilter : NewtonWorldRayPrefilterCallback);                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonWorldRayCast'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonWorldConvexCast( const newtonWorld : PNewtonWorld; const matrix : PFloat; const target : PFloat;
                                const shape : PNewtonCollision; hitParam : PFloat; userData: Pointer;
                                prefilter : NewtonWorldRayPrefilterCallback; info : PNewtonWorldConvexCastReturnInfo;
                                maxContactsCount : integer; threadIndex : integer) : Integer;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonWorldConvexCast'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonWorldGetBodyCount( const newtonWorld : PNewtonWorld) : integer;                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetBodyCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonWorldGetConstraintCount( const newtonWorld : PNewtonWorld) : integer;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetConstraintCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};


// *****************************************************************************************************************************
//
// Simulation islands
//
// *****************************************************************************************************************************

function  NewtonIslandGetBody( const island : Pointer; bodyIndex : integer) : PNewtonBody;                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonIslandGetBody'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonIslandGetBodyAABB( const island : Pointer; bodyIndex : integer; p0 : PFloat; p1 : PFloat);                                           cdecl; external{$IFDEF __GPC__}name 'NewtonIslandGetBodyAABB'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
//  Physics Material Section
//
// *****************************************************************************************************************************
function  NewtonMaterialCreateGroupID( const newtonWorld : PNewtonWorld ) : integer;                                                                 cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialCreateGroupID'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMaterialGetDefaultGroupID( const newtonWorld : PNewtonWorld ) : integer;                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetDefaultGroupID'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialDestroyAllGroupID( const newtonWorld : PNewtonWorld );                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialDestroyAllGroupID'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMaterialGetUserData( const NewtonWorld: PNewtonWorld; id0: integer; id1: integer): Pointer;                                              cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMaterialSetSurfaceThickness( const newtonWorld : PNewtonWorld; id0 : integer; id1 : integer; thickness : dFloat);                         cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetSurfaceThickness'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetContinuousCollisionMode (const newtonWorld : PNewtonWOrld; id0, id1, state : integer);                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContinuousCollisionMode'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMaterialSetCollisionCallback( const newtonWorld : PNewtonWorld; id0 : integer; id1 : integer; userData : Pointer;
                                              AABBOverlap : PNewtonOnAABBOverlap; process : PNewtonContactsProcess );                            cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetCollisionCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMaterialSetDefaultSoftness( const newtonWorld : PNewtonWorld; id0 : integer; id1 : integer; value : dfloat );                             cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetDefaultSoftness'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetDefaultElasticity( const newtonWorld : PNewtonWorld; id0 : integer; id1 : integer; elasticCoef : dfloat );                     cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetDefaultElasticity'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetDefaultCollidable( const newtonWorld : PNewtonWorld; id0 : integer; id1 : integer; state : integer );                             cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetDefaultCollidable'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetDefaultFriction( const newtonWorld : PNewtonWorld; id0 : integer; id1 : integer;
                                            staticFriction : dfloat; kineticFriction : dfloat );                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetDefaultFriction'{$ELSE}NEWTON_API{$ENDIF __GPC__};


function  NewtonWorldGetFirstMaterial( const NewtonWorld: PNewtonWorld): PNewtonMaterial;                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetFirstMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonWorldGetNextMaterial( const NewtonWorld: PNewtonWorld; const material : PNewtonMaterial): PNewtonMaterial;                       cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetNextMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonWorldGetFirstBody( const NewtonWorld: PNewtonWorld): PNewtonBody;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetFirstBody'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonWorldGetNextBody( const NewtonWorld: PNewtonWorld; const curBody : PNewtonBody): PNewtonBody;                                    cdecl; external{$IFDEF __GPC__}name 'NewtonWorldGetNextBody'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// Physics Contact control functions
//
// *****************************************************************************************************************************

function  NewtonMaterialGetMaterialPairUserData( const material : PNewtonMaterial) : Pointer;                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetMaterialPairUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMaterialGetContactFaceAttribute( const material : PNewtonMaterial) : Unsigned_int;                                               cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetContactFaceAttribute'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMaterialGetBodyCollisionID( const material : PNewtonMaterial; body : PNewtonBody) : Unsigned_int;                                cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetBodyCollisionID'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMaterialGetContactNormalSpeed( const material : PNewtonMaterial ) : dfloat;                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetContactNormalSpeed'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialGetContactForce(const Material : PNewtonMaterial; const Body : PNEwtonBody; Force : PFloat);                             cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetContactForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialGetContactPositionAndNormal(const Material : PNewtonMaterial; const Body : PNewtonBody; const Posit, Normal : PFloat);   cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetContactPositionAndNormal'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialGetContactTangentDirections(const Material : PNewtonMaterial; const Body : PNewtonBody; const Dir0, Dir1 : PFloat);      cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetContactTangentDirections'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMaterialGetContactTangentSpeed( const material : PNewtonMaterial; index : integer ) : dfloat;                                         cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialGetContactTangentSpeed'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMaterialSetContactSoftness( const material : PNewtonMaterial; softness : dfloat );                                                cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContactSoftness'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetContactElasticity( const material : PNewtonMaterial; restitution : dfloat );                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContactElasticity'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetContactFrictionState( const material : PNewtonMaterial; state : integer; index : integer );                                   cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContactFrictionState'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetContactFrictionCoef( const material : PNewtonMaterial; staticFrictionCoef,kineticFrictionCoef : dfloat;
                                               index : integer );                                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContactStaticFrictionCoef'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMaterialSetContactNormalAcceleration (const material : PNewtonMaterial; accel : dfloat);                                          cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContactNormalAcceleration'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialSetContactNormalDirection(const material : PNewtonMaterial; directionVector : PFloat);                                   cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContactNormalDirection'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMaterialSetContactTangentAcceleration( const material : PNewtonMaterial; accel : dfloat; index : integer );                           cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialSetContactTangentAcceleration'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMaterialContactRotateTangentDirections( const material : PNewtonMaterial; const directionVector : PFloat );                      cdecl; external{$IFDEF __GPC__}name 'NewtonMaterialContactRotateTangentDirections'{$ELSE}NEWTON_API{$ENDIF __GPC__};


// *****************************************************************************************************************************
//
// convex collision primitives creation functions
//
// *****************************************************************************************************************************

function  NewtonCreateNull( const newtonWorld : PNewtonWorld) : PNewtonCollision;                                                                                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonCreateNull'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateSphere( const newtonWorld : PNewtonWorld; radiusX, radiusY, radiusZ : dfloat; shapeID : integer; const offsetMatrix : PFloat ) : PNewtonCollision;                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonCreateSphere'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateBox( const newtonWorld : PNewtonWorld; dx : dfloat; dy : dfloat; dz : dfloat; shapeID : integer; const offsetMatrix : PFloat ) : PNewtonCollision;                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonCreateBox'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateCone( const newtonWorld : PNewtonWorld; radius : dFloat; height : dFloat; shapeID : integer; const offsetMatrix : PFloat) : PNewtonCollision;                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonCreateCone'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateCapsule( const newtonWorld : PNewtonWorld; radius : dFloat; height : dFloat; shapeID : integer; const offsetMatrix : PFloat) : PNewtonCollision;                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonCreateCapsule'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateCylinder( const newtonWorld : PNewtonWorld; radius : dFloat; height : dFloat; shapeID : integer; const offsetMatrix : PFloat) : PNewtonCollision;                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonCreateCylinder'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateChamferCylinder( const newtonWorld : PNewtonWorld; raduis : dFloat; height : dFloat; shapeID : integer; const offsetMatrix : PFloat) : PNewtonCollision;                                             cdecl; external{$IFDEF __GPC__}name 'NewtonCreateChamferCylinder'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateConvexHull( const newtonWorld : PNewtonWorld; count : integer; const vertexCloud : PFloat; strideInBytes : integer; tolerance : dfloat; shapeID : integer; const offsetMatrix : PFloat) : PNewtonCollision; cdecl; external{$IFDEF __GPC__}name 'NewtonCreateConvexHull'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCreateConvexHullFromMesh( const newtonWorld : PNewtonWorld; mesh : PNewtonMesh; tolerance : dFloat; shapeID : integer ) : PNewtonCollision;                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonCreateConvexHullFromMesh'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonCreateConvexHullModifier( const newtonWorld : PNewtonWorld; const convexHullCollision : PNewtonCollision; shapeID : integer): PNewtonCollision;                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonCreateConvexHullModifier'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonConvexHullModifierGetMatrix(const convexHullCollision : PNewtonCollision; matrix : PFloat);                                                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonConvexHullModifierGetMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonConvexHullModifierSetMatrix(const convexHullCollision : PNewtonCollision; const matrix : PFloat);                                                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonConvexHullModifierSetMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonCollisionIsTriggerVolume( const convexCollision : PNewtonCollision): integer;                                                                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionIsTriggerVolume'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonCollisionSetAsTriggerVolume( const convexCollision : PNewtonCollision; trigger : integer );                                                                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionSetAsTriggerVolume'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCollisionSetMaxBreakImpactImpulse( const convexHullCollision : PNewtonCollision; maxImpactImpulse : dFloat );                                                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionSetMaxBreakImpactImpulse'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCollisionGetMaxBreakImpactImpulse( const convexHullCollision : PNewtonCollision) : dFloat;                                                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionGetMaxBreakImpactImpulse'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCollisionSetUserID( const convexCollision : PNewtonCollision; id : unsigned_int );                                                                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionSetUserID'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCollisionGetUserID( const convexCollision : PNewtonCollision) : unsigned_int;                                                                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionGetUserID'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonConvexHullGetFaceIndices( const convexHullCollision : PNewtonCollision; face : integer; faceIndices : PInt) : integer;                                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonConvexHullGetFaceIndices'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonConvexCollisionCalculateVolume(const convexCollision : PNewtonCollision) : dFloat;                                                                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonConvexCollisionCalculateVolume'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonConvexCollisionCalculateInertialMatrix (const convexCollision : PNewtonCollision; inertia, origin : PFloat);                                                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonConvexCollisionCalculateInertialMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCollisionMakeUnique (const newtonWorld : PNewtonWorld; const collision : PNewtonCollision);                                                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionMakeUnique'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonReleaseCollision( const newtonWorld : PNewtonWorld; const collision : PNewtonCollision );                                                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonReleaseCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonAddCollisionReference( const Collision : PNewtonCollision): integer;                                                                                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonAddCollisionReference'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// complex collision primitives creation functions
// note: can only be used with static bodies (bodies with infinite mass)
//
// *****************************************************************************************************************************
type
  TCollisionPrimitiveArray = array of PNewtonCollision;

function NewtonCreateCompoundCollision( const newtonWorld : PNewtonWorld; count : integer;
                                        const collisionPrimitiveArray : TcollisionPrimitiveArray; shapeID : Integer ) : PNewtonCollision;            cdecl; external{$IFDEF __GPC__}name 'NewtonCreateCompoundCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonCreateCompoundCollisionFromMesh( const newtonWorld : PNewtonWorld; const mesh : PNewtonMesh; maxSubShapesCount : integer;
                                                shapeID : Integer; subShapeID : integer ) : PNewtonCollision;                                            cdecl; external{$IFDEF __GPC__}name 'NewtonCreateCompoundCollisionFromMesh'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonCreateUserMeshCollision( const newtonWorld : PNewtonWorld; const minBox : PFloat;
                                        const maxBox : PFloat; userData : Pointer; collideCallback : NewtonUserMeshCollisionCollideCallback;
                                        rayHitCallback : NewtonUserMeshCollisionRayHitCallback;
                                        destroyCallback : NewtonUserMeshCollisionDestroyCallback;
                                        getInfoCallback : NewtonUserMeshCollisionGetCollisionInfo;
                                        facesInAABBCallback : NewtonUserMeshCollisionGetFacesInAABB; shapeID : Integer ) : PNewtonCollision;         cdecl; external{$IFDEF __GPC__}name 'NewtonCreateUserMeshCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonCreateTreeCollisionFromMesh (const NewtonWorld : PNewtonWorld; const Mesh : PNewtonMesh; ShapeID : Integer) : PNewtonCollision;       cdecl; external{$IFDEF __GPC__}name 'NewtonCreateTreeCollisionFromMesh'{$ELSE}NEWTON_API{$ENDIF __GPC__};


function  NewtonCreateSceneCollision( const newtonWorld : PNewtonWorld; shapeID : Integer ) : PNewtonCollision;                                      cdecl; external{$IFDEF __GPC__}name 'NewtonCreateSceneCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonSceneCollisionCreateProxy( scene : PNewtonCollision; collision : PNewtonCollision ) : PNewtonSceneProxy;                         cdecl; external{$IFDEF __GPC__}name 'NewtonSceneCollisionCreateProxy'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSceneCollisionDestroyProxy( scene : PNewtonCollision; Proxy : PNewtonSceneProxy );                                               cdecl; external{$IFDEF __GPC__}name 'NewtonSceneCollisionDestroyProxy'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSceneProxySetMatrix( Proxy : PNewtonSceneProxy; const Matrix : PFloat );                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonSceneProxySetMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSceneProxyGetMatrix( Proxy : PNewtonSceneProxy; Matrix : PFloat );                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonSceneProxyGetMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSceneSetProxyUserData(const Proxy : PNewtonSceneProxy; UserData : Pointer);                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonSceneSetProxyUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonSceneGetProxyUserData(const Proxy : PNewtonSceneProxy) : Pointer;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonSceneGetProxyUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function NewtonSceneGetFirstProxy(const Scene : PNewtonCollision ) : PNewtonSceneProxy;                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonSceneGetFirstProxy'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function NewtonSceneGetNextProxy(const Scene : PNewtonCollision; const Proxy : PNewtonSceneProxy ) : PNewtonSceneProxy;                          cdecl; external{$IFDEF __GPC__}name 'NewtonSceneGetNextProxy'{$ELSE}NEWTON_API{$ENDIF __GPC__};


procedure NewtonSceneCollisionOptimize( scene : PNewtonCollision );                                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonSceneCollisionOptimize'{$ELSE}NEWTON_API{$ENDIF __GPC__};


// **********************************************************************************************
//
// complex breakable collision primitives interface
//
// **********************************************************************************************
function NewtonCreateCompoundBreakable( const NewtonWorld : PNewtonWorld; meshCount : integer; const SolidsArray : PNewtonMesh; const ShapeIDArray : PInt; Densities : PFloat; internalFaceMaterial : PInt; ShapeID : Integer; debrisID : Integer; DebrisSeparationGap : dFloat ) : PNewtonCollision; cdecl; external{$IFDEF __GPC__}name 'NewtonCreateCompoundBreakable'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCompoundBreakableResetAnchoredPieces( const compoundBreakable : PNewtonCollision );                                                                                                                                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonCompoundBreakableResetAnchoredPieces'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonCompoundBreakableSetAnchoredPieces( const compoundBreakable : PNewtonCollision; fixshapesCount : Integer; matrixPallete : PFloat; fixedShapesArray : PNewtonCollision );                                                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonCompoundBreakableSetAnchoredPieces'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonCompoundBreakableGetVertexCount( const compoundBreakable : PNewtonCollision ) : Integer;                                                                                                                                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonCompoundBreakableGetVertexCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonCompoundBreakableGetVertexStreams( const compoundBreakable : PNewtonCollision; vertexStrideInByte : Integer; Vertex : PFloat; normalStrideInByte : Integer; normal : PFloat; uvStrideInByte : Integer; uv : PFloat );                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonCompoundBreakableGetVertexStreams'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBreakableGetMainMesh( const compoundBreakable : PNewtonCollision ) : PNewtonBreakableComponentMesh;                                                                                                                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableGetMainMesh'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBreakableGetFirstComponent( const compoundBreakable : PNewtonCollision ) : PNewtonBreakableComponentMesh;                                                                                                                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableGetFirstComponent'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBreakableGetNextComponent( const component : PNewtonBreakableComponentMesh ) : PNewtonBreakableComponentMesh;                                                                                                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableGetNextComponent'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBreakableBeginDelete( const compoundBreakable : PNewtonCollision );                                                                                                                                                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableBeginDelete'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBreakableCreateDebrieBody( const compoundBreakable : PNewtonCollision; const component : PNewtonBreakableComponentMesh ) : PNewtonBody;                                                                                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableCreateDebrieBody'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBreakableDeleteComponent( const compoundBreakable : PNewtonCollision; const component : PNewtonBreakableComponentMesh );                                                                                                                                                 cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableDeleteComponent'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBreakableEndDelete( const compoundBreakable : PNewtonCollision );                                                                                                                                                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableBeginDelete'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBreakableGetComponentsInRadius( const compoundBreakable : PNewtonCollision; const position : PFloat; radius : dFloat; Segments : PNewtonBreakableComponentMesh; maxCount : Integer ) : Integer;                                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableGetComponentsInRadius'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBreakableGetFirstSegment( const BreakableComponent : PNewtonBreakableComponentMesh ) : Pointer;                                                                                                                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableGetFirstSegment'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBreakableGetNextSegment( const Segment : Pointer ) : Pointer;                                                                                                                                                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableGetNextSegment'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBreakableSegmentGetMaterial( const Segment : Pointer ) : Integer;                                                                                                                                                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableSegmentGetMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBreakableSegmentGetIndexCount( const Segment : Pointer ) : Integer;                                                                                                                                                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableSegmentGetIndexCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBreakableSegmentGetIndexStream( CompoundBreakable : PNewtonCollision; const MeshOwner : PNewtonBreakableComponentMesh; const Segment : Pointer; Index : PInt ) : Integer;                                                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableSegmentGetIndexStream'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBreakableSegmentGetIndexStreamShort( CompoundBreakable : PNewtonCollision; const MeshOwner : PNewtonBreakableComponentMesh; const Segment : Pointer; Index : PShort ) : Integer;                                                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonBreakableSegmentGetIndexStreamShort'{$ELSE}NEWTON_API{$ENDIF __GPC__};


//  ***********************************************************************************************************
//
//	Collision serialization functions
//
// ***********************************************************************************************************

function NewtonCreateCollisionFromSerialization( const newtonWorld : PNewtonWorld; deserializeFunction : PNewtonDeserialize; serializeHandle : Pointer ) : PNewtonCollision; cdecl; external{$IFDEF __GPC__}name 'NewtonCreateCollisionFromSerialization'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCollisionSerialize( const newtonWorld : PNewtonWorld; const collision : PNewtonCollision; serializeFunction : PNewtonSerialize; serializeHandle : Pointer ); cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionSerialize'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCollisionGetInfo( const collision : PNewtonCollision; collisionInfo : PNewtonCollisionInfoRecord); cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionGetInfo'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// **********************************************************************************************
//
// Static collision shapes functions
//
// **********************************************************************************************

function  NewtonCreateHeightFieldCollision( const newtonWorld : PNewtonWorld; width, height, gridDiagonals : integer; elevationMap : PUnsigned_short; attributeMap : P2Char; horizontalScale,verticalScale : dFloat; shapeID : Integer) : PNewtonCollision; cdecl; external{$IFDEF __GPC__}name 'NewtonCreateHeightFieldCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonHeightFieldSetUserRayCastCallback (const TreeCollision : PNewtonCollision; RayHitCallBack : PNewtonHeightFieldRayCastCallback); cdecl; external{$IFDEF __GPC__}name 'NewtonHeightFieldSetUserRayCastCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonCreateTreeCollision( const newtonWorld : PNewtonWorld; shapeID : Integer ) : PNewtonCollision; cdecl; external{$IFDEF __GPC__}name 'NewtonCreateTreeCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonTreeCollisionSetUserRayCastCallback( const treeCollision : PNewtonCollision; rayHitCallback : PNewtonCollisionTreeRayCastCallback ); cdecl; external{$IFDEF __GPC__}name 'NewtonTreeCollisionSetUserRayCastCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonTreeCollisionBeginBuild( const treeCollision : PNewtonCollision ); cdecl; external{$IFDEF __GPC__}name 'NewtonTreeCollisionBeginBuild'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonTreeCollisionAddFace( const treeCollision : PNewtonCollision; vertexCount : integer; const vertexPtr : PFloat;
                                      strideInBytes : integer; faceAttribute : integer ); cdecl; external{$IFDEF __GPC__}name 'NewtonTreeCollisionAddFace'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonTreeCollisionEndBuild( const treeCollision : PNewtonCollision; optimize : integer ); cdecl; external{$IFDEF __GPC__}name 'NewtonTreeCollisionEndBuild'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonTreeCollisionGetFaceAtribute( const treeCollision : PNewtonCollision; const faceIndexArray : Pint ) : integer; cdecl; external{$IFDEF __GPC__}name 'NewtonTreeCollisionGetFaceAtribute'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonTreeCollisionSetFaceAtribute( const treeCollision : PNewtonCollision; const faceIndexArray : Pint;
                                              attribute : integer ); cdecl; external{$IFDEF __GPC__}name 'NewtonTreeCollisionSetFaceAtribute'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonTreeCollisionGetVertexListIndexListInAABB( const treeCollision : PNewtonCollision; const p0, p1 : PFloat; const vertexArray : PFloat; vertexCount,vertexStrideInBytes : PInt; const indexList : PInt; maxIndexCount : Integer; const faceAttribute : PInt ) : integer; cdecl; external{$IFDEF __GPC__}name 'NewtonTreeCollisionGetVertexListIndexListInAABB'{$ELSE}NEWTON_API{$ENDIF __GPC__};


procedure NewtonStaticCollisionSetDebugCallback( const staticCollision : PNewtonCollision; userCallback : PNewtonTreeCollisionCallback ); cdecl; external{$IFDEF __GPC__}name 'NewtonStaticCollisionSetDebugCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};


// *****************************************************************************************************************************
//
// General purpose collision library functions
//
// *****************************************************************************************************************************

function  NewtonCollisionPointDistance (const newtonWorld : PNewtonWorld; const point : PFloat;
		                                    const collision : PNewtonCollision; const matrix : PFloat;	contact : PFloat;
                                        normal : PFloat; threadIndex : integer) : Integer;                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionPointDistance'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonCollisionClosestPoint (const newtonWorld : PNewtonWorld; const collsionA : PNewtonCollision;
                                       const matrixA : PFloat; const collisionB : PNewtonCollision; const matrixB : PFloat;
		                                   contactA, contactB, normalAB : PFloat; threadIndex : integer) : Integer;                                          cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionClosestPoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonCollisionCollide (const newtonWorld : PNewtonWorld; maxSize : Integer; const collsionA : PNewtonCollision;
                                  const matrixA : PFloat; const collisionB : PNewtonCollision; const matrixB : PFloat;
                                  contacts, normals, penetration : PFloat; threadIndex : integer) : Integer;                                             cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionCollide'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonCollisionCollideContinue(const newtonWorld : PNewtonWorld; maxSize : Integer; const timestep : dFloat;
		                                    const collsionA : PNewtonCollision; const matrixA : PFloat; const velocA : PFloat; const omegaA : dFloat;
		                                    const collsionB : PNewtonCollision; const matrixB : PFloat; const velocB : PFloat; const omegaB : dFloat;
		                                    timeOfImpact : PFloat; contacts : PFloat; normals : PFloat;
                                        penetration : PFloat; threadIndex : integer) : Integer;                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionCollideContinue'{$ELSE}NEWTON_API{$ENDIF __GPC__};


procedure NewtonCollisionSupportVertex( const collision : PNewtonCollision; const dir : PFloat; vertex : PFloat);                                cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionSupportVertex'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCollisionRayCast(const collision : PNewtonCollision; const p0: PFloat; const p1: PFloat;
                                 normals: PFloat; attribute: pint): dfloat;                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionRayCast'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonCollisionCalculateAABB( const collision : PNewtonCollision; const matrix : PFloat; p0 : PFloat; p1 : PFloat );                   cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionCalculateAABB'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonCollisionForEachPolygonDo (const collision : PNewtonCollision; const matrix : PFloat; callback : NewtonCollisionIterator;
                                           UserData : Pointer);                                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonCollisionForEachPolygonDo'{$ELSE}NEWTON_API{$ENDIF __GPC__};


// *****************************************************************************************************************************
//
// transforms utility functions
//
// *****************************************************************************************************************************
procedure NewtonGetEulerAngle( const matrix : PFloat; eulersAngles : PFloat );                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonGetEulerAngle'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSetEulerAngle( const eulersAngles : PFloat; matrix : PFloat );                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonSetEulerAngle'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonCalculateSpringDamperAcceleration(dt, ks, x, kd, s : dFloat): dfloat;                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonCalculateSpringDamperAcceleration'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// body manipulation functions
//
// *****************************************************************************************************************************
function  NewtonCreateBody( const newtonWorld : PNewtonWorld; const collision : PNewtonCollision; const Matrix : PFloat) : PNewtonBody;          cdecl; external{$IFDEF __GPC__}name 'NewtonCreateBody'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonDestroyBody( const newtonWorld : PNewtonWorld; const body : PNewtonBody );                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonDestroyBody'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyAddForce( const body : PNewtonBody; const force : PFloat );                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBodyAddForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyAddTorque( const body : PNewtonBody; const torque : PFloat );                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBodyAddTorque'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyCalculateInverseDynamicsForce(const body : PNewtonBody; timestep : dFloat; const desiredVeloc : PFloat; forceOut : PFloat );  cdecl; external{$IFDEF __GPC__}name 'NewtonBodyCalculateInverseDynamicsForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetMatrix( const body : PNewtonBody; const matrix : PFloat );                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetMatrixRecursive( const body : PNewtonBody; const matrix : PFloat );                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetMatrixRecursive'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetMassMatrix( const body : PNewtonBody; mass : dfloat; Ixx : dfloat; Iyy : dfloat; Izz : dfloat );                              cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetMassMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetMaterialGroupID( const body : PNewtonBody; id : integer );                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetMaterialGroupID'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetContinuousCollisionMode(const body : PNewtonbody; state : integer);                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetContinuousCollisionMode'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetJointRecursiveCollision( const body : PNewtonBody; state : unsigned_int );                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetJointRecursiveCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetOmega( const body : PNewtonBody; const omega : PFloat );                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetOmega'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetVelocity( const body : PNewtonBody; const velocity : PFloat );                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetVelocity'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetForce( const body : PNewtonBody; const force : PFloat );                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetTorque( const body : PNewtonBody; const torque : PFloat );                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetTorque'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetCentreOfMass(const body : PNewtonBody; const com : PFloat);                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetCentreOfMass'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetLinearDamping( const body : PNewtonBody; linearDamp : dfloat );                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetLinearDamping'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetAngularDamping( const body : PNewtonBody; const angularDamp : PFloat );                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetAngularDamping'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodySetUserData( const body : PNewtonBody; userData : Pointer );                                                                 cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetCollision( const body : PNewtonBody; const collision : PNewtonCollision );                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBodyGetSleepState( const body : PNewtonBody) : Integer;                                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetSleepState'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBodyGetAutoSleep( const body : PNewtonBody) : Integer;                                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetAutoSleep'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetAutoSleep( const body : PNewtonBody; state : integer );                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetAutoSleep'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBodyGetFreezeState( const body : PNewtonBody) : Integer;                                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetFreezeState'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetFreezeState( const body : PNewtonBody; state : integer );                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetFreezeState'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetDestructorCallback( const body : PNewtonBody; callback : NewtonBodyDestructor );                                          cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetDestructorCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetTransformCallback( const body : PNewtonBody; callback : NewtonSetTransform );                                             cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetTransformCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function NewtonBodyGetTransformCallback( const body : PNewtonBody ): NewtonSetTransform;                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetForceAndTorqueCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodySetForceAndTorqueCallback( const body : PNewtonBody; callback : NewtonApplyForceAndTorque );                                 cdecl; external{$IFDEF __GPC__}name 'NewtonBodySetForceAndTorqueCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function NewtonBodyGetForceAndTorqueCallback( const body : PNewtonBody ): NewtonApplyForceAndTorque;                                             cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetForceAndTorqueCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetUserData( const body : PNewtonBody ) : Pointer;                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetWorld( const body : PNewtonBody) : PNewtonWorld;                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetWorld'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetCollision( const body : PNewtonBody ) : PNewtonCollision;                                                                 cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetMaterialGroupID( const body : PNewtonBody ) : Integer;                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetMaterialGroupID'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBodyGetContinuousCollisionMode( const body : PNewtonBody ) : Integer;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetContinuousCollisionMode'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetJointRecursiveCollision( const body : PNewtonBody ) : Integer;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetJointRecursiveCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyGetMatrix( const body : PNewtonBody; matrix : PFloat );                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyGetRotation( const body : PNewtonBody; rotation : PFloat );                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetRotation'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetMassMatrix( const body : PNewtonBody; mass : PFloat; Ixx : PFloat; Iyy : PFloat; Izz : PFloat );                          cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetMassMatrix'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetInvMass( const body : PNewtonBody; invMass : PFloat; invIxx : PFloat; invIyy : PFloat; invIzz : PFloat );                 cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetInvMass'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetOmega( const body : PNewtonBody; vector : PFloat );                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetOmega'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetVelocity( const body : PNewtonBody; vector : PFloat );                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetVelocity'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetForce( const body : PNewtonBody; vector : PFloat );                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetTorque( const body : PNewtonBody; vector : PFloat);                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetTorque'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyGetForceAcc( const body : PNewtonBody; vector : PFloat );                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetForceAcc'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyGetTorqueAcc( const body : PNewtonBody; vector : PFloat );                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetTorqueAcc'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetCentreOfMass(const body : PNewtonBody; com : PFloat);                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetCentreOfMass'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBodyGetLinearDamping( const body : PNewtonBody ) : dfloat;                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetLinearDamping'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetAngularDamping( const body : PNewtonBody; vector : PFloat );                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetAngularDamping'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBodyGetAABB( const body : PNewtonBody; p0 : PFloat; p1 : PFloat );                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetAABB'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyGetFreezeTreshold( const body : PNewtonBody; freezeSpeed2 : PFloat; freezeOmega2 : PFloat );                                 cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetFreezeTreshold'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonBodyGetFirstJoint( const body : PNewtonBody ) : PNewtonJoint;                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetFirstJoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetNextJoint( const body : PNewtonBody; const joint : PNewtonJoint ) : PNewtonJoint;                                         cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetNextJoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetFirstContactJoint( const body : PNewtonBody ) : PNewtonJoint;                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetFirstContactJoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonBodyGetNextContactJoint( const body : PNewtonBody; const contactJoint : PNewtonJoint ) : PNewtonJoint;                           cdecl; external{$IFDEF __GPC__}name 'NewtonBodyGetNextContactJoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonContactJointGetFirstContact( const contactJoint : PNewtonJoint ) : Pointer;                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonContactJointGetFirstContact'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonContactJointGetNextContact( const contactJoint : PNewtonJoint; contact : Pointer ) : Pointer;                                    cdecl; external{$IFDEF __GPC__}name 'NewtonContactJointGetNextContact'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonContactJointGetContactCount( const contactJoint : PNewtonJoint ) : integer;                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonContactJointGetContactCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonContactJointRemoveContact( const contactJoint : PNewtonJoint; contact : Pointer );                                               cdecl; external{$IFDEF __GPC__}name 'NewtonContactJointRemoveContact'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function NewtonContactGetMaterial( const contact : Pointer ) : PNewtonMaterial;                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonContactGetMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyAddBuoyancyForce( const body : PNewtonBody; fluidDensity : dfloat; fluidLinearViscosity, fluidAngularViscosity : dfloat;
                                      const gravityVector : PFloat; buoyancyPlane : NewtonGetBuoyancyPlane; context : Pointer );                 cdecl; external{$IFDEF __GPC__}name 'NewtonBodyAddBuoyancyForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyAddImpulse(const body : PNewtonBody; const pointDeltaVeloc : PFloat; const pointPosit : PFloat );                            cdecl; external{$IFDEF __GPC__}name 'NewtonAddBodyImpulse'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonBodyApplyImpulseArray (const Body : PNewtonBody; ImpuleCount : Integer; StrideInByte : Integer; const impulseArray : PFloat;
                                       const pointArray : PFloat);                                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonBodyApplyImpulseArray'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// Common joint funtions
//
// *****************************************************************************************************************************
function  NewtonJointGetUserData( const joint : PNewtonJoint ) : Pointer;                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonJointGetUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonJointSetUserData( const joint : PNewtonJoint; userData : Pointer );                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonJointSetUserData'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonJointGetBody0( const joint : PNewtonJoint ) : PNewtonBody;                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonJointGetBody0'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonJointGetBody1( const joint : PNewtonJoint ) : PNewtonBody;                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonJointGetBody1'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonJointGetInfo( const joint : PNewtonJoint; info : PNewtonJointRecord );                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonJointGetInfo'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonJointGetCollisionState( const joint : PNewtonJoint ) : integer;                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonJointGetCollisionState'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonJointSetCollisionState( const joint : PNewtonJoint; state : integer );                                                               cdecl; external{$IFDEF __GPC__}name 'NewtonJointSetCollisionState'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonJointGetStiffness( const joint : PNewtonJoint): dfloat;                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonJointGetStiffness'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonJointSetStiffness( const joint: PNewtonJoint; state: dfloat);                                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonJointSetStiffness'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonDestroyJoint( const newtonWorld : PNewtonWorld; const joint : PNewtonJoint );                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonDestroyJoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonJointSetDestructor( const joint : PNewtonJoint; _destructor : NewtonConstraintDestructor );                                      cdecl; external{$IFDEF __GPC__}name 'NewtonJointSetDestructor'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// Ball and Socket joint functions
//
// *****************************************************************************************************************************
function  NewtonConstraintCreateBall( const newtonWorld : PNewtonWorld; const pivotPoint : PFloat;
                                      const childBody : PNewtonBody; const parentBody : PNewtonBody ) : PNewtonJoint;                            cdecl; external{$IFDEF __GPC__}name 'NewtonConstraintCreateBall'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBallSetUserCallback( const ball : PNewtonJoint; callback : NewtonBallCallBack );                                                 cdecl; external{$IFDEF __GPC__}name 'NewtonBallSetUserCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBallGetJointAngle( const ball : PNewtonJoint; angle : PFloat );                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBallGetJointAngle'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBallGetJointOmega( const ball : PNewtonJoint; omega : PFloat );                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBallGetJointOmega'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBallGetJointForce( const ball : PNewtonJoint; force : PFloat );                                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonBallGetJointForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonBallSetConeLimits( const ball : PNewtonJoint; const pin : PFloat; maxConeAngle : dfloat; maxTwistAngle : dfloat );                 cdecl; external{$IFDEF __GPC__}name 'NewtonBallSetConeLimits'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// Hinge joint functions
//
// *****************************************************************************************************************************
function  NewtonConstraintCreateHinge( const newtonWorld : PNewtonWorld;
                                       const pivotPoint : PFloat; const pinDir : PFloat;
                                       const childBody : PNewtonBody; const parentBody : PNewtonBody ) : PNewtonJoint;                           cdecl; external{$IFDEF __GPC__}name 'NewtonConstraintCreateHinge'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonHingeSetUserCallback( const hinge : PNewtonJoint; callback : NewtonHingeCallBack );                                              cdecl; external{$IFDEF __GPC__}name 'NewtonHingeSetUserCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonHingeGetJointAngle( const hinge : PNewtonJoint ) : dfloat;                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonHingeGetJointAngle'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonHingeGetJointOmega( const hinge : PNewtonJoint ) : dfloat;                                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonHingeGetJointOmega'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonHingeGetJointForce( const hinge : PNewtonJoint; force : PFloat );                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonHingeGetJointForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonHingeCalculateStopAlpha( const hinge : PNewtonJoint; const desc : PNewtonHingeSliderUpdateDesc; angle : dfloat ) : dfloat;         cdecl; external{$IFDEF __GPC__}name 'NewtonHingeCalculateStopAlpha'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// Slider joint functions
//
// *****************************************************************************************************************************
function  NewtonConstraintCreateSlider( const newtonWorld : PNewtonWorld;
                                        const pivotPoint : PFloat; const pinDir : PFloat;
                                        const childBody : PNewtonBody; const parentBody : PNewtonBody ) : PNewtonJoint;                          cdecl; external{$IFDEF __GPC__}name 'NewtonConstraintCreateSlider'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSliderSetUserCallback( const slider : PNewtonJoint; callback : NewtonSliderCallBack );                                           cdecl; external{$IFDEF __GPC__}name 'NewtonSliderSetUserCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonSliderGetJointPosit( const slider : PNewtonJoint ) : dfloat;                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonSliderGetJointPosit'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonSliderGetJointVeloc( const slider : PNewtonJoint ) : dfloat;                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonSliderGetJointVeloc'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonSliderGetJointForce( const slider : PNewtonJoint; force : PFloat );                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonSliderGetJointForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonSliderCalculateStopAccel( const slider : PNewtonJoint; const desc : PNewtonHingeSliderUpdateDesc; position : dfloat ) : dfloat;    cdecl; external{$IFDEF __GPC__}name 'NewtonSliderCalculateStopAccel'{$ELSE}NEWTON_API{$ENDIF __GPC__};


// *****************************************************************************************************************************
//
// Corkscrew joint functions
//
// *****************************************************************************************************************************
function  NewtonConstraintCreateCorkscrew( const newtonWorld : PNewtonWorld;
                                           const pivotPoint : PFloat; const pinDir : PFloat;
                                           const childBody : PNewtonBody; const parentBody : PNewtonBody ) : PNewtonJoint;                       cdecl; external{$IFDEF __GPC__}name 'NewtonConstraintCreateCorkscrew'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonCorkscrewSetUserCallback( const corkscrew : PNewtonJoint; callback : NewtonCorkscrewCallBack );                                  cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewSetUserCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCorkscrewGetJointPosit( const corkscrew : PNewtonJoint ) : dfloat;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewGetJointPosit'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCorkscrewGetJointAngle( const corkscrew : PNewtonJoint ) : dfloat;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewGetJointAngle'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCorkscrewGetJointVeloc( const corkscrew : PNewtonJoint ) : dfloat;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewGetJointVeloc'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCorkscrewGetJointOmega( const corkscrew : PNewtonJoint ) : dfloat;                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewGetJointOmega'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonCorkscrewGetJointForce( const corkscrew : PNewtonJoint; force : PFloat );                                                        cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewGetJointForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCorkscrewCalculateStopAlpha(const corkscrew : PNewtonJoint;const desc : PNewtonHingeSliderUpdateDesc;angle : dfloat) : dfloat;     cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewCalculateStopAlpha'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonCorkscrewCalculateStopAccel(const corkscrew : PNewtonJoint;const desc : PNewtonHingeSliderUpdateDesc;position : dfloat) : dfloat;  cdecl; external{$IFDEF __GPC__}name 'NewtonCorkscrewCalculateStopAccel'{$ELSE}NEWTON_API{$ENDIF __GPC__};


// *****************************************************************************************************************************
//
// Universal joint functions
//
// *****************************************************************************************************************************
function  NewtonConstraintCreateUniversal( const newtonWorld: PNewtonWorld; const pivotPoint: PFloat; const pinDir0: PFloat;
                                          const pinDir1: PFloat; const childBody: PNewtonBody; const parentBody: PNewtonBody): PNewtonJoint;     cdecl; external{$IFDEF __GPC__}name 'NewtonConstraintCreateUniversal'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUniversalSetUserCallback(const universal: PNewtonJoint; callback: NewtonUniversalCallback);                                      cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalSetUserCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonUniversalGetJointAngle0(const universal: PNewtonJoint):dfloat;                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalGetJointAngle0'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonUniversalGetJointAngle1(const universal: PNewtonJoint):dfloat;                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalGetJointAngle1'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonUniversalGetJointOmega0(const universal: PNewtonJoint):dfloat;                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalGetJointOmega0'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonUniversalGetJointOmega1(const universal: PNewtonJoint):dfloat;                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalGetJointOmega1'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUniversalGetJointForce(const universal: PNewtonJoint; force: PFloat);                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalGetJointForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonUniversalCalculateStopAlpha0(const universal : PNewtonJoint; const desc: PNewtonHingeSliderUpdateDesc; angle: dfloat): dfloat;     cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalCalculateStopAlpha0'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonUniversalCalculateStopAlpha1(const universal : PNewtonJoint; const desc: PNewtonHingeSliderUpdateDesc; angle: dfloat): dfloat;     cdecl; external{$IFDEF __GPC__}name 'NewtonUniversalCalculateStopAlpha1'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// Up vector joint unctions
//
// *****************************************************************************************************************************
function  NewtonConstraintCreateUpVector( const newtonWorld : PNewtonWorld; const pinDir : PFloat; const body : PNewtonBody ) : PNewtonJoint;    cdecl; external{$IFDEF __GPC__}name 'NewtonConstraintCreateUpVector'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUpVectorGetPin( const upVector : PNewtonJoint; pin : PFloat );                                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonUpVectorGetPin'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUpVectorSetPin( const upVector : PNewtonJoint; const pin : PFloat );                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonUpVectorSetPin'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// *****************************************************************************************************************************
//
// User defined bilateral Joint
//
// *****************************************************************************************************************************
function  NewtonConstraintCreateUserJoint(const NewtonWorld : PNewtonWorld; MaxDOF : Integer; Callback : PNewtonUserBilateralCallBack;
                                          GetInfo : PNewtonUserBilateralGetInfoCallBack; const ChildBody: PNewtonBody;
                                          const parentBody: PNewtonBody): PNewtonJoint;                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonConstraintCreateUserJoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointSetFeedbackCollectorCallback(const Joint : PNewtonJoint; GetFeedback : PNewtonUserBilateralCallBack);                   cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointSetFeedbackCollectorCallback'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointAddLinearRow(const Joint : PNewtonJoint; const pivot0 : PFloat; const pivot1 : PFloat; const Dir : PFloat);             cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointAddLinearRow'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointAddAngularRow(const Joint : PNewtonJoint; RelativeAngle : dFloat; const Dir : PFloat);                                   cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointAddAngularRow'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointAddGeneralRow(const Joint : PNewtonJoint; const Jacobian0 : PFloat; const Jacobian1 : PFloat);                          cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointAddGeneralRow'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointSetRowMinimumFriction(const Joint : PNewtonJoint; Friction : dFloat);                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointSetRowMinimumFriction'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointSetRowMaximumFriction(const Joint : PNewtonJoint; Friction : dFloat);                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointSetRowMaximumFriction'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointSetRowAcceleration(const Joint : PNewtonJoint; Acceleration : dFloat);                                                   cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointSetRowAcceleration'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointSetRowSpringDamperAcceleration(const joint : PNewtonJoint; springK : dFloat; springD : dFloat);                           cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointSetRowSpringDamperAcceleration'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonUserJointSetRowStiffness(const Joint : PNewtonJoint; Stiffness : dFloat);                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointSetRowStiffness'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonUserJointGetRowForce (const Joint : PNewtonJoint; Row : Integer) : dFloat;                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonUserJointGetRowForce'{$ELSE}NEWTON_API{$ENDIF __GPC__};

// **********************************************************************************************
//
// Mesh joint functions
//
// **********************************************************************************************

function  NewtonMeshCreate (const World : PNewtonWorld) : PNewtonMesh;                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreate'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshCreateFromMesh(const Mesh : PNewtonMesh) : PNewtonMesh;                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreateFromMesh'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshCreateFromCollision (const collision : PNewtonCollision) : PNewtonMesh;                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreateFromCollision'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshConvexHull (const NewtonWorld : PNewtonWorld; count : integer; const vertexCloud : PFloat; strideInBytes : integer;
                                tolerance : dfloat) : PNewtonMesh;                                                                                cdecl; external{$IFDEF __GPC__}name 'NewtonMeshConvexHull'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshCreatePlane (const World : PNewtonWorld; const locationMatrix : PFloat; width : dFloat; breadth : dFloat; material : Integer;
                                 const textureMatrix0 : PFloat; const textureMatrix1) : PNewtonMesh;                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreatePlane'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshDestroy(const mesh : PNewtonMesh);                                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshDestroy'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshCalculateOOBB(const mesh : PNewtonMesh; const matrix : PFloat; x : PFloat; y : PFloat; z : PFloat);                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCalculateOOBB'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMesApplyTransform (const Mesh : PNewtonMesh; const Matrix : PFloat);                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMesApplyTransform'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshCalculateVertexNormals(const mesh : PNewtonMesh; angleInRadians : dFloat);                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCalculateVertexNormals'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshApplySphericalMapping(const mesh : PNewtonMesh; material : integer);              cdecl; external{$IFDEF __GPC__}name 'NewtonMeshApplySphericalMapping'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshApplyBoxMapping(const mesh : PNewtonMesh; front,side,top : integer);              cdecl; external{$IFDEF __GPC__}name 'NewtonMeshApplyBoxMapping'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshApplyCylindricalMapping(const mesh : PNewtonMesh; cylinderMaterial,capMaterial : integer);                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMeshApplyCylindricalMapping'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshIsOpenMesh (const mesh : PNewtonMesh) : Integer;                                                                                 cdecl; external{$IFDEF __GPC__}name 'NewtonMeshIsOpenMesh'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshFixTJoints (const mesh : PNewtonMesh);                                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMeshFixTJoints'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshPolygonize (const mesh : PNewtonMesh);                                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMeshPolygonize'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshTriangulate (const mesh : PNewtonMesh);                                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshTriangulate'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshUnion (const mesh : PNewtonMesh; clipper : PNewtonMesh; clipperMatrix : PFloat) : PNewtonMesh;                               cdecl; external{$IFDEF __GPC__}name 'NewtonMeshUnion'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshDifference (const mesh : PNewtonMesh; clipper : PNewtonMesh; clipperMatrix : PFloat) : PNewtonMesh;                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshDifference'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshIntersection (const mesh : PNewtonMesh; clipper : PNewtonMesh; clipperMatrix : PFloat) : PNewtonMesh;                        cdecl; external{$IFDEF __GPC__}name 'NewtonMeshIntersection'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshClip (const mesh : PNewtonMesh; const clipper : PNewtonMesh; const clippermatrix : PFloat; const topMesh : PNewtonMesh;
                          const bottomMesh : PNewtonMesh);                                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMeshClip'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshPlaneClip (const Mesh : PNewtonMesh; const planeMatrix : PFloat; const PlaneTextureMatrix : PFloat; PlaneMaterial : Integer;
                               const topMesh : PNewtonMesh; const bottomMesh : PNewtonMesh);                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonMeshPlaneClip'{$ELSE}NEWTON_API{$ENDIF __GPC__};


function  NewtonMeshConvexDecomposition (const Mesh : PNewtonMesh; MaxCount : Integer) : PNewtonMesh;                                                cdecl; external{$IFDEF __GPC__}name 'NewtonMeshConvexDecomposition'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshVoronoiDecomposition (const Mesh : PNewtonMesh; PointCount, PointStrideInBytes : Integer; const PointCloud : PFloat;
                                          InternalMaterial : Integer; const TextureMatrix : PFloat) : PNewtonMesh;                                   cdecl; external{$IFDEF __GPC__}name 'NewtonMeshVoronoiDecomposition'{$ELSE}NEWTON_API{$ENDIF __GPC__};


procedure NewtonRemoveUnusedVertices(const mesh : PNewtonMesh; vertexRemapTable : PInt);                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonRemoveUnusedVertices'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshBeginFace(const mesh : PNewtonMesh);                                                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonMeshBeginFace'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshAddFace(const mesh : PNewtonMesh; vertexCount : integer; const vertex : PFloat; strideInBytes,materialIndex : integer );             cdecl; external{$IFDEF __GPC__}name 'NewtonMeshAddFace'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshEndFace(const mesh : PNewtonMesh);                                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshEndFace'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshBuildFromVertexListIndexList(const Mesh : PNewtonMesh;
		FaceCount : Integer; const faceIndexCount : PInt; const faceMaterialIndex : PInt;
		const vertex : PFloat; vertexStrideInBytes : Integer; const vertexIndex : PInt;
		const normal : PFloat; normalStrideInBytes : Integer; const normalIndex : PInt;
		const uv0 : PFloat; uv0StrideInBytes : Integer; const uv0Index : PInt;
		const uv1 : PFloat; uv1StrideInBytes : Integer; const uv1Index : PInt);                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshBuildFromVertexListIndexList'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshGetVertexStreams(const Mesh : PNewtonMesh; vertexStrideInByte : Integer; Vertex : PFloat; normalStrideInByte : integer;
                                     Normal : PFloat; uvStrideInByte0 : Integer; uv0 : PFloat; uvStrideInByte1 : Integer; uv1 : PFloat);                 cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetVertexStreams'{$ELSE}NEWTON_API{$ENDIF __GPC__};

procedure NewtonMeshGetIndirectVertexStreams(const mesh : PNewtonMesh; vertexStrideInByte : integer; vertex : PFloat; vertexIndices : PInt;
                                             vertexCount : PInt; normalStrideInByte : integer; normal : PFloat; normalIndices : PInt;
                                             normalCount : PInt; uvStrideInByte0 : integer; uv0 : PFloat; uvIndices0 : PInt; uvCount0 : PInt;
                                             uvStrideInByte1 : integer; uv1 : PFloat; uvIndices1 : PInt; uvCount1 : PInt);                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetIndirectVertexStreams'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshBeginHandle (const mesh : PNewtonMesh) : Pointer;                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonMeshBeginHandle'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshEndHandle (const mesh : PNewtonMesh; Handle : Pointer);                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshEndHandle'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshFirstMaterial (const mesh : PNewtonMesh; Handle : Pointer) : integer;                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonMeshFirstMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshNextMaterial (const mesh : PNewtonMesh; Handle : Pointer; materialID : integer) : integer;                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshNextMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshMaterialGetMaterial (const mesh : PNewtonMesh; Handle : Pointer; materialID : integer) : integer;                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMeshMaterialGetMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshMaterialGetIndexCount (const mesh : PNewtonMesh; Handle : Pointer; materialID : integer) : integer;                                  cdecl; external{$IFDEF __GPC__}name 'NewtonMeshMaterialGetIndexCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshMaterialGetIndexStream(const mesh : PNewtonMesh; Handle : Pointer; materialID : integer; index : PInt);                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshMaterialGetIndexStream'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshMaterialGetIndexStreamShort(const mesh : PNewtonMesh; Handle : Pointer; materialID : integer; index : PShort);                   cdecl; external{$IFDEF __GPC__}name 'NewtonMeshMaterialGetIndexStreamShort'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshCreateFirstSingleSegment (const mesh : PNewtonMesh) : PNewtonMesh;                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreateFirstSingleSegment'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshCreateNextSingleSegment (const mesh : PNewtonMesh; Segment : PNewtonMesh) : PNewtonMesh;                                     cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreateNextSingleSegment'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshCreateFirstLayer(const Mesh : PNewtonMesh) : PNewtonMesh;                                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreateFirstLayer'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshCreateNextLayer(const Mesh : PNewtonMesh; const Segment : PNewtonMesh) : PNewtonMesh;                                        cdecl; external{$IFDEF __GPC__}name 'NewtonMeshCreateNextLayer'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshGetTotalFaceCount (const mesh : PNewtonMesh) : Integer;                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetTotalFaceCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetTotalIndexCount (const mesh : PNewtonMesh) : Integer;                                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetTotalIndexCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshGetFaces (const mesh : PNewtonMesh; const faceIndexCount : PInt; faceMaterial : PInt; faceIndices : PInt);                   cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFaces'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshGetPointCount (const Mesh : PNewtonMesh) : Integer;                                                                              cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetPointCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetPointStrideInByte (const Mesh : PNewtonMesh) : Integer;                                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetPointStrideInByte'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetPointArray (const Mesh : PNewtonMesh): PFloat;                                                                            cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetPointArray'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshGetNormalArray (const Mesh : PNewtonMesh) : PFloat;                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetNormalArray'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetUV0Array (const Mesh : PNewtonMesh) : PFloat;                                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetUV0Array'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetUV1Array (const Mesh : PNewtonMesh) : PFloat;                                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetUV1Array'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshGetVertexCount (const Mesh : PNewtonMesh) : Integer;                                                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetVertexCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetVertexStrideInByte (const Mesh : PNewtonMesh) : Integer;                                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetVertexStrideInByte'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetVertexArray (const Mesh : PNewtonMesh) : PFloat;                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetVertexArray'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshGetFirstVertex (const Mesh : PNewtonMesh) : Pointer;                                                                         cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFirstVertex'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetNextVertex (const Mesh : PNewtonMesh; const Vertex : Pointer) : Pointer;                                                  cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetNextVertex'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetVertexIndex (const Mesh : PNewtonMesh; const Vertex : Pointer) : Integer;                                                     cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetVertexIndex'{$ELSE}NEWTON_API{$ENDIF __GPC__};
//NEWTON_API int NewtonMeshGetVertexPointIndex (const NewtonMesh *mesh, const void* vertex);

function  NewtonMeshGetFirstPoint (const Mesh : PNewtonMesh) : Pointer;                                                                          cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFirstPoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetNextPoint (const Mesh : PNewtonMesh; const point : Pointer) : Pointer;                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetNextPoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetPointIndex (const Mesh : PNewtonMesh; const point : Pointer) : Integer;                                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetPointIndex'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetVertexIndexFromPoint (const Mesh : PNewtonMesh; const point : Pointer) : Integer;                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetVertexIndexFromPoint'{$ELSE}NEWTON_API{$ENDIF __GPC__};

function  NewtonMeshGetFirstEdge (const Mesh : PNewtonMesh) : Pointer;                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFirstEdge'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetNextEdge (const Mesh : PNewtonMesh; const Edge : Pointer) : Pointer;                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetNextEdge'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshGetEdgeIndices (const Mesh : PNewtonMesh; const Edge : Pointer; v0 : PInt; v1 : PInt);                                       cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetEdgeIndices'{$ELSE}NEWTON_API{$ENDIF __GPC__};
//NEWTON_API void NewtonMeshGetEdgePointIndices (const Mesh : PNewtonMesh, const void* edge, int* v0, int* v1);

function  NewtonMeshGetFirstFace (const Mesh : PNewtonMesh) : Pointer;                                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFirstFace'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetNextFace (const Mesh : PNewtonMesh; const Face : Pointer) : Pointer;                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetNextFace'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshIsFaceOpen (const Mesh : PNewtonMesh; const Face : Pointer) : Integer;                                                           cdecl; external{$IFDEF __GPC__}name 'NewtonMeshIsFaceOpen'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetFaceMaterial (const Mesh : PNewtonMesh; const Face : Pointer) : Integer;                                                      cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFaceMaterial'{$ELSE}NEWTON_API{$ENDIF __GPC__};
function  NewtonMeshGetFaceIndexCount (const Mesh : PNewtonMesh; const Face : Pointer) : Integer;                                                    cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFaceIndexCount'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshGetFaceIndices (const Mesh : PNewtonMesh; const Face : Pointer; Indices : PInt);                                             cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFaceIndices'{$ELSE}NEWTON_API{$ENDIF __GPC__};
procedure NewtonMeshGetFacePointIndices (const Mesh : PNewtonMesh; const Face : Pointer; Indices : PInt);                                        cdecl; external{$IFDEF __GPC__}name 'NewtonMeshGetFacePointIndices'{$ELSE}NEWTON_API{$ENDIF __GPC__};


implementation

end.

